Test Cases in Tests.py.

Fixed code in: XXNetworkServer.py

# -------------  Vulnerabilities ---------------- #


I. Denial of Service vulnerabilities in the LOGOUT mechanism:

	This is the current LOGOUT method:

	elif cs[0] == "LOGOUT":
                    if cs[1] in self.tokens :
                        self.tokens.remove(cs[1])

    Brute-forcing `LOGOUT AUTH_TOKEN` programmatically can cause a race condition where we attempt to remove AUTH_TOKEN after it has already been removed. This would throw a system error and bring down the server. A simple fix is to add error handling in this function:

    	elif cs[0] == "LOGOUT":
                    if cs[1] in self.tokens :
                        try:
                            self.tokens.remove(cs[1])
                        except:
                            pass

    LOGOUT [TOKEN] can also be executed by anyone for any session token without other authentication mechanisms in place. This is exacerbated by the fact that Auth tokens are returned in clear plaintext, so an attacker listening on the server could gather active session tokens and invalidate them. This means that although we've prevented a DOS attack that could bring down the server, an attacker brute-forcing LOGOUT session keys could still launch a client-side DOS attack.

	The fix for this would be require auth check in order to LOGOUT, and limit to only current session so that no user can delete another users's token.

	Instead of allowing `LOGOUT [SESSION TOKEN]` without any auth, `LOGOUT` will now require a valid session token to run, and will only log out of the current session. The command would look like this: `session_token;LOGOUT`

	Patch Changes:
	- Change in UI. LOGOUT [TOKEN] is now [TOKEN];LOGOUT
	- Refactor run() method in SampleNetworkServer.py
	- Separate server processCommands() function into login() for `AUTH`, and processCommands() for everything else.
	- Modify processCommands() function to take session token as a param and process `LOGOUT`
	- Add error handling and descriptive feedback in logout mechanism

	The above fixes should limit DOS vulnerability and prevent a chaining attacks such as:

	`VALID_TOKEN;LOGOUT RANDOM_TOKEN;LOGOUT RANDOM_TOKEN;LOGOUT RANDOM_TOKEN`


II. Access Control Failure: able to execute commands without actually authenticating.
	
	To preproduce manually:
	```
	nc -u 127.0.0.1 23457
	AUTH whatever;COMMAND
	```

	Example:
	`AUTH whatever;GET_TEMP` yields 317.923439

	See test case for programmatic exploit.

	The vulnerability lies in the server run() command. There is only an authorization token check if command input is one string (i.e. TOKEN;COMMAND.) The authentication control only triggers when the first command is not AUTH or LOGOUT.

	By passing in `AUTH whatever;GET_TEMP` or `LOGOUT whatever;GET_TEMP`, we execute processCommands() for the first half of the chain with no output, and bypass authentication and authorization controls for `GET_TEMP`.

	A few assumptions I made for the fix:
	- The user cannot chain `AUTH` and `LOGOUT` commands with other commands.
	- The issue should be fixed without changing the UI.
	- The fix should not significantly refactor the code or alter system architecture

	Code changes:
	- the server run() method was refactored to patch Bug I and Bug II.
	- run() fails fast if there are no active sessions.
	- Add check in processOpenCommand() to fail if argument after `AUTH` is not auth key.

	This removes the loophole completely, but also changes current behavior.

	Users cannot run `AUTH !Q#E%T&U8i6y4r2w;COMMAND_1;COMMAND_2` to authenticate and chain commands. They must first authenticate to receive an Auth token, then send commands in the format `AUTH_TOKEN;COMMAND_1;COMMAND_2`. Though I suspect this was the intended behavior anyway.
	

III. Setting temperature to C or F breaks temperature calculations for the Incubator temperature. This bug doesn't cause the same wild inconsistencies in Infant temperature calculations. However, on both servers, the bug makes the temperature line disappear from the display in the client.

	Output on Incubator server:

	```
	TOKEN;GET_TEMP
	318.023637
	TOKEN;SET_DEGC;GET_TEMP
	44.739294
	TOKEN;SET_DEGF;GET_TEMP
	158.204801
	TOKEN;SET_DEGC;GET_TEMP
	72.847908
	TOKEN;SET_DEGK;GET_TEMP
	346.772770
	TOKEN;SET_DEGC;GET_TEMP
	45.099606

	```

	On infant server:

	```
	TOKEN;GET_TEMP
	312.687938
	TOKEN;SET_DEGC;GET_TEMP
	39.823611
	TOKEN;SET_DEGF;GET_TEMP
	103.792068
	TOKEN;SET_DEGC;GET_TEMP
	39.918676
	TOKEN;SET_DEGK;GET_TEMP
	313.006279
	```

	Solution:

	The root of the problem lies in the server `getTemperature()` function. It does conditional arithmatics and returns different values for when self.deg is C, K, or F. The client graphs temperature by periodically polling the server for current temperature:

		self.infTemps.append(self.infTherm.getTemperature()-273)
		self.incTemps.append(self.incTherm.getTemperature()-273)

	Since it always subtracts 273, when degree is not set to Kelvin, this method call returns negative numbers for non-Kelvin temperatures. I can deduce that the wild discrepancy in temperature for the Incubator temperature comes from the complex arithmatics used in infinc.py to calculate incubator temperature; while the infant temperature remains more constant. This might uncover another vulnerability: I noticed that the F to C conversion is wildly off (temperature jumps up to 72 degrees C), but converting back to K and then to C resets the temperature to normal.

	I added a helper method convertTemperature(), which converts whatever current temperature is to Celcius to fit the Client display parameters. This solved the main issue in this bug, since Client-side now displays the converted temperature in Celsius. However... I added logging and discovered that after `SET_DEGC` and `SET_DEGF`, the incubator temperature climbs wildly into the 70s. THis reveals that the root of this lies in the math in "infinc.py".



III. Changing degrees to C or F breaks Client



 V. A pseudo-random authentication key hard-coded into the server also isn't secure.

 	Solution: I added a database to the server and added the password as a salted and encrypted field, so that it is no longer hard-coded into the server code.