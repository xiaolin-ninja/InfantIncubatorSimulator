Test Cases in Tests.py.

Fixed code in: XXNetworkServer.py

# -------------  Vulnerabilities ---------------- #

I. Able to send commands without actually authenticating.
	To preproduce:
	```
	nc -u 127.0.0.1 23457
	AUTH whatever;COMMAND
	```

	Example:
	`AUTH whatever;GET_TEMP` yields 317.923439

	See test case for programmatic exploit.

	The vulnerabilities lies in the server run() command. There is only an authorization token check if command input is one string (i.e. TOKEN;COMMAND.) The authentication control only triggers when the first command is not AUTH or LOGOUT.

	By passing in `AUTH whatever;GET_TEMP` or `LOGOUT whatever;GET_TEMP`, we execute processCommands() for the first half with no output, and bypass authentication and authorization controls for `GET_TEMP`.

	A few assumptions I made about the fix:
	- The user cannot chain `AUTH` and `LOGOUT` commands with other commands.
	- The issue should be fixed without changing the UI.
	- The fix should not significantly refactor the code

	Code changes:
	- Separated server processCommands() function into processOpenCommand() for `AUTH` and `LOGOUT`, and processCommands() for everything else. 
	- refactor server run() method to follow two logic paths for whether command is for user login/out, or hardware control. This removes the loophole completely, but also changes current behavior. Users cannot run `AUTH !Q#E%T&U8i6y4r2w;COMMAND_1;COMMAND_2` to authenticate and chain commands. They must first authenticate, then send commands in the format `AUTH_TOKEN;COMMAND_1;COMMAND_2`
	- refactor server run() method to fail-fast if there are no tokens.
	- add check in processOpenCommand() to fail if argument after `AUTH` is not auth key.
	- LOGOUT AUTH_TOKEN now returns a descriptive message on success


II. Changing temperature settings breaks Incubator temperature calculations. This bug doesn't cause the same wild inconsistencies in Infant temperature calculations. However, on both servers, this bug makes the temperature line disappear in the client.

	Output on Incubator server:

	```
	TOKEN;GET_TEMP
	318.023637
	TOKEN;SET_DEGC;GET_TEMP
	44.739294
	TOKEN;SET_DEGF;GET_TEMP
	158.204801
	TOKEN;SET_DEGC;GET_TEMP
	72.847908
	TOKEN;SET_DEGK;GET_TEMP
	346.772770
	TOKEN;SET_DEGC;GET_TEMP
	45.099606

	```

	On infant server:

	```
	TOKEN;GET_TEMP
	312.687938
	TOKEN;SET_DEGC;GET_TEMP
	39.823611
	TOKEN;SET_DEGF;GET_TEMP
	103.792068
	TOKEN;SET_DEGC;GET_TEMP
	39.918676
	TOKEN;SET_DEGK;GET_TEMP
	313.006279
	```

	Solution:

	The root of the problem lies in the server `getTemperature()` function. It does conditional arithmatics and returns different values for when self.deg is C, K, or F. The client graphs temperature by periodically polling the server for current temperature:

		self.infTemps.append(self.infTherm.getTemperature()-273)
		self.incTemps.append(self.incTherm.getTemperature()-273)

	Since it always subtracts 273, when degree is set to not Kelvin, this method call returns negative numbers for non-Kelvin temperatures. The wild discrepancy in temperature for the Incubator temperature I can deduce comes from the complex arithmatics in infinc.py to calculate incubator temperature; while the infant temperature remains more constant. This might uncover another vulnerability: I noticed that the F to C conversion is wildly off (temperature jumps up to 72 degrees C), but converting back to K and then to C resets the temperature to normal.

	I added a helper method convertTemperature(), which converts whatever current temperature is to Celcius to fit the Client display parameters. This solved the main issue in this bug, since Client-side now displays the converted temperature in Celsius. However... I added logging and discovered that after `SET_DEGC` and `SET_DEGF`, the incubator temperature climbs wildly into the 70s. THis reveals that the root of this lies in the math in "infinc.py".


III. Changing degrees to C or F breaks Client



IV. Another vulnerabilities lies in the logout method:
	elif cs[0] == "LOGOUT":
                    if cs[1] in self.tokens :
                        self.tokens.remove(cs[1])

    brute-forcing `LOGOUT AUTH_TOKEN` programmatically can cause a race condition where we enter the nested if function and attempt to remove AUTH_TOKEN after it has already been removed. This would throw an error and break the program. A simple fix is to add error catching in this function:

    	elif cs[0] == "LOGOUT":
                    if cs[1] in self.tokens :
                        try:
                            self.tokens.remove(cs[1])
                        except:
                            pass

    I opted to pass rather than return any message to limit the information feedback to a potential attacker.


 V. A pseudo-random authentication key hard-coded into the server also isn't secure.

 	Solution: I added a database to the server and added the password as a salted and encrypted field, so that it is no longer hard-coded into the server code.