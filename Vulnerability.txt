Tests for Vulnerabilities 1 - 5 in Tests.py, using SampleNetworkServer.py
Tests for Vulnerability 6 is in TLSTests.py, using TLSNetworkServer.py

# -------------  Vulnerabilities ---------------- #


I. Denial of Service vulnerabilities in the LOGOUT mechanism:

	This is the current LOGOUT method:

	elif cs[0] == "LOGOUT":
                    if cs[1] in self.tokens :
                        self.tokens.remove(cs[1])

    Brute-forcing `LOGOUT AUTH_TOKEN` programmatically can cause a race condition where we attempt to remove AUTH_TOKEN after it has already been removed. This would throw a system error and bring down the server. A simple fix is to add error handling in this function:

    	elif cs[0] == "LOGOUT":
                    if cs[1] in self.tokens :
                        try:
                            self.tokens.remove(cs[1])
                        except:
                            pass

    LOGOUT [TOKEN] can also be executed by anyone for any session token without other authentication mechanisms in place. This is exacerbated by the fact that Auth tokens are returned in clear plaintext, so an attacker listening on the server could gather active session tokens and invalidate them. This means that although we've prevented a DOS attack that could bring down the server, an attacker brute-forcing LOGOUT session keys could still launch a client-side DOS attack.

	The fix for this would be require auth check in order to LOGOUT, and limit to only current session so that no user can delete another users's token.

	Instead of allowing `LOGOUT [SESSION TOKEN]` without any auth, `LOGOUT` will now require a valid session token to run, and will only log out of the current session. The command would look like this: `session_token;LOGOUT`

	Patch Changes:
	- Change in UI. LOGOUT [TOKEN] is now [TOKEN];LOGOUT
	- Refactor run() method in SampleNetworkServer.py
	- Separate server processCommands() function into login() for `AUTH`, and processCommands() for everything else.
	- Modify processCommands() function to take session token as a param and process `LOGOUT`
	- Add error handling and descriptive feedback in logout mechanism

	The above fixes should limit DOS vulnerability and prevent a chaining attacks such as:

	`VALID_TOKEN;LOGOUT RANDOM_TOKEN;LOGOUT RANDOM_TOKEN;LOGOUT RANDOM_TOKEN`


II. Access Control Failure: able to execute commands without actually authenticating.
	
	To preproduce manually:
	```
	nc -u 127.0.0.1 23457
	AUTH whatever;COMMAND
	```

	Example:
	`AUTH whatever;GET_TEMP` yields 317.923439

	See test case for programmatic exploit.

	The vulnerability lies in the server run() command. There is only an authorization token check if command input is one string (i.e. TOKEN;COMMAND.) The authentication control only triggers when the first command is not AUTH or LOGOUT.

	By passing in `AUTH whatever;GET_TEMP` or `LOGOUT whatever;GET_TEMP`, we execute processCommands() for the first half of the chain with no output, and bypass authentication and authorization controls for `GET_TEMP`.

	A few assumptions I made for the fix:
	- The user cannot chain `AUTH` and `LOGOUT` commands with other commands.
	- The issue should be fixed without changing the UI.
	- The fix should not significantly refactor the code or alter system architecture

	Code changes:
	- the server run() method was refactored to patch Bug I and Bug II.
	- run() fails fast if there are no active sessions.
	- Add check in processOpenCommand() to fail if argument after `AUTH` is not auth key.

	This removes the loophole completely, but also changes current behavior.

	Users cannot run `AUTH !Q#E%T&U8i6y4r2w;COMMAND_1;COMMAND_2` to authenticate and chain commands. They must first authenticate to receive an Auth token, then send commands in the format `AUTH_TOKEN;COMMAND_1;COMMAND_2`. Though I suspect this was the intended behavior anyway.
	

III. Setting temperature to C or F breaks temperature calculations for the Incubator temperature. This bug doesn't cause the same wild inconsistencies in Infant temperature calculations. However, on both servers, the bug makes the temperature line disappear from the display in the client.

	Output on Incubator server:

	```
	TOKEN;GET_TEMP
	318.023637
	TOKEN;SET_DEGC;GET_TEMP
	44.739294
	TOKEN;SET_DEGF;GET_TEMP
	158.204801
	TOKEN;SET_DEGC;GET_TEMP
	72.847908
	TOKEN;SET_DEGK;GET_TEMP
	346.772770
	TOKEN;SET_DEGC;GET_TEMP
	45.099606

	```

	On infant server:

	```
	TOKEN;GET_TEMP
	312.687938
	TOKEN;SET_DEGC;GET_TEMP
	39.823611
	TOKEN;SET_DEGF;GET_TEMP
	103.792068
	TOKEN;SET_DEGC;GET_TEMP
	39.918676
	TOKEN;SET_DEGK;GET_TEMP
	313.006279
	```

	Solution:

	The root of the problem lies in the server `getTemperature()` function. It does conditional arithmatics and returns different values for when self.deg is C, K, or F. The client graphs temperature by periodically polling the server for current temperature:

		self.infTemps.append(self.infTherm.getTemperature()-273)
		self.incTemps.append(self.incTherm.getTemperature()-273)

	Since it always subtracts 273, when degree is not set to Kelvin, this method call returns negative numbers for non-Kelvin temperatures. I added a helper method convertTemperature(), which converts whatever current temperature is to Celcius to fit the Client display parameters. This solved the main issue in this bug, since Client-side now displays the converted temperature in Celsius. However... I added logging and discovered that after `SET_DEGC` and `SET_DEGF`, the incubator temperature climbs wildly into the 70s while infant temprature remains more constant. This reveals that the root of this lies in the math in "infinc.py". That would be a big, complex separate bug that's outside of the scope of the time I have allocated for this assignment.


IV. Confidentiality Risk: Hard-Coded Secrets in Server and Client Code

	Credentials definitely should not be hard-coded into source code. If the source code is leaked, it would hand an attacker the keys to the castle. This also implies that all servers use the same hard-coded password, which greatly increases the risk.

	The solution is to store credentials as environment variables. I used dotenv to do this.

	On the server-side in SampleNetworkServer.py:

	def login(self, cs, addr): #process AUTH command
        if cs[0] == "AUTH":
            if cs[1] == os.environ.get('SECRET_KEY'):
            	...


	On the client-side in SampleNetworkClient.py:

	def updateInfTemp(self, frame) :
        self.updateTime()
        if self.infToken is None : #not yet authenticated
            self.infToken = self.authenticate(self.infPort, os.environ.get('SECRET_KEY_CLIENT').encode('utf-8'))
            ...

    def updateIncTemp(self, frame) :
        self.updateTime()
        if self.incToken is None : #not yet authenticated
        	self.incToken = self.authenticate(self.incPort, os.environ.get('SECRET_KEY_CLIENT').encode('utf-8'))
        	....



V. A pseudo-random authentication key shared by the server and client isn't secure. The key length is also too short to be secure. It is also not encrypted or properly stored. On a real server, we could use something like AWS Lambda to encrypt and decrypt environment variables. This requires extensive refactoring, so I won't include that here.


VI. Man-in-the-Middle Vulnerability: Unencrypted and plaintext information sent over the network

Captured UDP packets on Wireshark show that network communications are not encrypted at all. Packets contain both the password and authetication token, which allows full access to the network thermometer. In addition, this device is a medical device and must follow regulations and laws such as HIPAAA. Personal medical information about the infant is available in plaintext in the packets. An attacker could easily set up a man-in-the-middle attack to collect sensitive data, and this accessibility also increases the risk of vulnerability I discussed earlier.

In the test, I ask the server for the temperature and then convert the response to a float. If it converts, then the message was unencrypted. If it throws an error, then the message was encrypted and not a number. A Wireshark capture also confirms that communications are encrypted.

The solution is to implement encryption on the application or transport layer. TLS is the way to go here to encrypt network traffic and add an additional layer of protection for the access control vulnerabilities identified above. TLS only works with TCP, and not UDP. This works out great, because I also wanted to change the connection from UDP to TCP. Plain UDP does not perform the handshake, leaving it susceptible to spoofing attacks. UDP also does not retransmit lost packets, which is inconvenient for our system that requires consistency and reliable data reporting to generate the client-side temperature display. UDP offers performance advantages over TCP, but in this case, unlike VOIP, communications with the infant incubator don't really need priority on the network, and don't need to bypass congestion controls. 

I setup a self-signed SSL certificate with the following steps:

> openssl req -out infinc.csr -new -newkey rsa:2048 -nodes -keyout private.key
> openssl x509 -signkey private.key -in infinc.csr -req -days 365 -out infinc.crt


I added SSL and converted to TCP in TLSNetworkServer.py:

        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        context.load_cert_chain(certfile='./infinc.crt',keyfile='./private.key')

        sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
        sock.bind(("127.0.0.1", port))

        self.serverSocket = context.wrap_socket(sock, server_side=True)

TLSNetworkClient.py in methods getTemperatureFromPort() and authenticate(), lines 41-59.


This is the point where we have two sets of tests to avoid rewriting everything. Tests related to TLS will be in a separate test file, and use a separate client and servers prefaced by "TLS" in the file names.



